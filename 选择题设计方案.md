# 选择题设计方案

## 方案概述

采用**前端配置答案 + Markdown 内容**的方案：

1. **语雀编写** - 在语雀上方便编写题目内容，不包含答案
2. **前端存储答案** - 答案配置在前端代码中，用户无法通过查看源文件获得
3. **智能渲染** - Markdown 自动识别选项并转换为可点击的选择题组件

## 数据结构

### 1. 在 `src/data/courses.ts` 中配置答案

```typescript
{
  id: 2,
  type: "choice",        // 标识为选择题
  title: "选择题",
  content: {
    type: "md",          // 内容仍为 Markdown
    src: "/002-选择题.md"
  },
  // 答案配置（前端存储，用户看不到）
  answer: {
    correct: "A",        // 正确答案
    explanation: "详细解析..."  // 可选的答案解析
  }
}
```

### 2. Markdown 文件格式 (`002-选择题.md`)

````markdown
以下代码运行什么？

```python
def print_double(x):
    print(2 * x)
print_double(3)
```
````

- A. 6
- B. 2
- C. 3
- D. 0

````

## 技术实现

### 1. 增强的 Markdown 组件

**新增 Props:**
```typescript
interface Props {
  src?: string;
  isQuiz?: boolean;        // 是否为选择题
  quizAnswer?: QuizAnswer; // 答案配置
}
````

**自定义列表渲染:**

- 检测到 `isQuiz = true` 时，将 `- A. 选项` 格式转换为可点击的选择题组件
- 普通列表正常渲染

### 2. 交互逻辑

**点击选项:**

1. 对比用户选择与正确答案
2. 显示正确/错误提示
3. 显示答案解析（如果有）
4. 禁用后续点击
5. 通知父组件答题状态

**状态管理:**

- `hasAnswered` - 是否已答题
- 下一步按钮：选择题必须答题后才能继续

## 使用流程

### 1. 语雀编写内容

```markdown
题目描述...

代码块...

- A. 选项1
- B. 选项2
- C. 选项3
- D. 选项4
```

### 2. 导出到本地

```
public/Markdown/Python/yuque/002-选择题.md
```

### 3. 配置答案

```typescript
// src/data/courses.ts
{
  type: "choice",
  answer: {
    correct: "A",
    explanation: "解析内容..."
  }
}
```

### 4. 自动渲染

- 系统检测到 `type: "choice"`
- 自动启用选择题模式
- 选项变为可点击的交互组件

## 优势

✅ **内容安全**

- 答案存储在前端代码中
- 语雀文件中不包含答案
- 用户无法通过查看 Markdown 文件获得答案

✅ **编写便利**

- 在语雀上正常编写 Markdown
- 支持代码高亮、格式化等功能
- 选项使用标准列表格式

✅ **交互完整**

- 点击选项立即反馈
- 正确/错误状态显示
- 答案解析展示
- 答题验证机制

✅ **维护简单**

- 题目内容和答案分离
- 修改题目不需要改代码
- 添加新题目只需配置答案

## 测试示例

访问 `/step/python/python-basics/1/2`：

1. **显示效果**
   - 题目：以下代码运行什么？
   - 代码：Python 代码高亮显示
   - 选项：A、B、C、D 可点击卡片

2. **交互效果**
   - 点击选项 A：✅ 回答正确！解析内容...
   - 点击其他选项：❌ 回答错误！正确答案是 A。解析内容...
   - 答题后下一步按钮可用

这个方案既保证了答案的安全性，又提供了良好的编写和交互体验！🎉
